# -*- coding: utf-8 -*-
"""DS_HW3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1anbiosFy6jAydAhzIA8HxUrKywH9WG45
"""

#importing necessary packages
import numpy as np
import matplotlib.pyplot as plt
import math

#importing the data text file and converting columns into arrays
#remember to change directory to wherever the data file is saved

Data_file = np.loadtxt("IceCube_Data_Project3.txt")
Time= Data_file[:,0]
Energy= Data_file[:,1]
RA= np.deg2rad(Data_file[:,3])
Dec= np.deg2rad(Data_file[:,4])

#Part 1 - marginal PDF
#Time
fig1, ax1 = plt.subplots()
ax1.hist(Time,bins =100, density=True)
ax1.set_title("Time Marginal PDF")
ax1.set_ylabel("pdf")
ax1.set_xlabel("Time in days")
fig2, ax2 = plt.subplots()
ax2.hist(Energy,bins=100, density=True)
ax2.set_title("Energy Marginal PDF")
ax2.set_ylabel("pdf")
ax2.set_xlabel("log10(Energy/GeV)")
fig3, ax3 = plt.subplots()
ax3.hist(RA,bins=100,density=True)
ax3.set_title("Right Ascension PDF")
ax3.set_ylabel("pdf")
ax3.set_xlabel("Right Ascension in radians")
fig4, ax4 = plt.subplots()
ax4.hist(np.sin(Dec),bins=100,density=True)
ax4.set_title("Declination Marginal PDF")
ax4.set_ylabel("pdf")
ax4.set_xlabel("sine of declination")
print("We plot the sine of declination because the project of the declination in a 2D plane does not provide an even and accurate projection but taking the sine of it accounts for it.")

#part 2 - marginal CDF
fig5, ax5 = plt.subplots()
ax5.hist(Energy, bins=100, density=True, cumulative=True)
ax5.axvline(np.quantile(Energy,0.1),linestyle=':',label='10th quantile', color = 'yellow')
ax5.axvline(np.quantile(Energy,0.5),linestyle=':', label = '50th quantile',color = 'red')
ax5.axvline(np.quantile(Energy,0.9),linestyle=':', label = '90th quantile',color = 'green')
ax5.axvline(np.mean(Energy),label = 'average', color = 'orange')
ax5.axvline((np.mean(Energy) + np.sqrt(np.var(Energy,ddof=1))),label ='plus std dev',linestyle='--',color = 'pink')
ax5.axvline((np.mean(Energy) - np.sqrt(np.var(Energy,ddof=1))),label = 'minus std dev', linestyle='--',color = 'purple')
ax5.set_title("Energy Marginal CDF")
ax5.set_ylabel("cdf")
ax5.set_xlabel("log10(Energy/GeV)")
ax5.legend(loc='upper right')

#part 3 - plot the differences for consecutive times that are greater than 1000 and positive
#Sathvik told me about a easy function to use to find the consecutive entries that is np.ediff1d that I will also be using to simplify the work
diff_Time = np.ediff1d(Time)#finds all the diferences
positive_Time = diff_Time[diff_Time>0]#finds all the positive time differences
in_secs = positive_Time*24*60*60 #converting days to seconds
final_Time = in_secs[in_secs<1000]#finds all the time differences less than 1000
fig6, ax6 = plt.subplots()
ax6.hist(final_Time,bins =100, density=True)
ax6.set_title("Sorted Time Differences Marginal PDF")
ax6.set_ylabel("log pdf")
ax6.set_xlabel("Time difference in seconds")

#part 4 - use np.hist2d for joint pdf
fig7, ax7 = plt.subplots()
ax7.hist2d(Energy,np.sin(Dec),bins =100)
ax7.set_title("Joint pdf of Energy and sine of Declination")
ax7.set_ylabel("log10(Energy/GeV)")
ax7.set_xlabel("sine of Declination")

#part 5
reduced_RA= RA[0:10000]-np.pi
reduced_Dec=Dec[0:10000]
fig7 = plt.figure()
ax7 = fig7.add_subplot(111, projection='mollweide')
ax7.scatter(reduced_RA,reduced_Dec,s=1)
ax7.set_title("Mollweide plot of RA and DEC")

#part 6
fig8, ax8 = plt.subplots()
ax8.hist2d(RA,np.sin(Dec),bins =100)
ax8.set_title("Joint pdf of RA and sine of Declination")
ax8.set_xlabel("RA in radians")
ax8.set_ylabel("sine of Declination")

#part 7 - energy and sine of dec nothern sky
print("This is the covariance matrix for the northern sky")
Dec_northern=[]
Energy_northern=[]
for i in range(len(Dec)):
  if Dec[i] > np.radians(-5):
    Dec_northern.append(Dec[i])
    Energy_northern.append(Energy[i])
stacked_n = np.stack((Energy_northern,np.sin(Dec_northern)),axis=0)
cov_mat_northern = np.cov(stacked_n)
print(cov_mat_northern)

#part 8 - energy and sine of dec southern sky
print("This is the covariance matrix for the southern sky")
Dec_southern=[]
Energy_southern=[]
for i in range(len(Dec)):
  if Dec[i] < np.radians(-5):
    Dec_southern.append(Dec[i])
    Energy_southern.append(Energy[i])
stacked_s = np.stack((Energy_southern,np.sin(Dec_southern)),axis=0)
cov_mat_southern = np.cov(stacked_s)
print(cov_mat_southern)

#part 9
x1,x2 = np.random.choice(Dec_southern, 2) #x1 and x2 are two of the random numbers from the northern sky
Dec_southern=np.asarray(Dec_southern)
dx = np.sqrt(np.var(Dec_southern/len(Dec_southern))) #set differentiable limit dx as 0.5
x1_E = Energy[np.logical_and(Dec >= (x1-dx/2), Dec <= (x1+dx/2))] #np.logical_and gives you truth values of two arrays
x2_E = Energy[np.logical_and(Dec >= (x2-dx/2), Dec <= (x2+dx/2))]
fig8, ax8 = plt.subplots()
ax8.hist(x1_E,bins=100,density=True)
ax8.set_title("Conditional PDF of Energy at" + str("{:2f}".format(x1) +"radians"))
ax8.set_ylabel("PDF")
ax8.set_xlabel("log(Energy/GeV)")
fig9, ax9 = plt.subplots()
ax9.hist(x2_E,bins=10,density=True)
ax9.set_title("Conditional PDF of Energy at" + str("{:2f}".format(x2) +"radians"))
ax9.set_ylabel("PDF")
ax9.set_xlabel("log(Energy/GeV)")

#part 10
print("The northern hemisphere has more data points that the southern presumably due to the tilt of the Earth on it's axis that causes the muons to decay. So the muon data is filtered out of the data points for the southern hemisphere")

print("It took me around 6 hours to do this project")