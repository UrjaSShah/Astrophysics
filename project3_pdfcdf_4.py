# -*- coding: utf-8 -*-
"""Project3_pdfcdf-4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cwdZY8KVCAt1ppzllklOEEaLr4jj01Gw

### How to read the IceCube Data

---
- First column is in days (Modified Julian Day). We will care about the last digit of it
&nbsp;
&nbsp;
- Second column are in log 10 base $\log_{10} \frac{E}{GeV}$
- Third column is uncertainty (picutre it as 1 standard deviation = 68%) that is the radius of that small circle
- Fourth column is ascension which is longitude
- Fifth column is declination which is latitude

---
- Question 5 matplotlib has the function to plot Mollewiede
- This way of projection preserve the area.
- To debug make some fake data set to plot it.
"""

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
import math

# Q9 pick -5 to -90 for declination

jday = []
loge = []
uncert = []
ascen = []
decli = []

# using with so no need to do close()
with open("IceCube_Data_Project3.txt", "r") as source:
    all = source.readlines()
    for incident in all:
        for i, item in enumerate(incident.split()):
            if i == 0:
                jday.append(float(item))
            if i == 1:
                loge.append(float(item))
            if i == 2:
                uncert.append(float(item))
            if i == 3:
                ascen.append(float(item))
            if i == 4:
                decli.append(float(item))

day = np.array(jday)
e = np.array(loge)
unc = np.array(uncert)
asc = np.array(ascen)
dec = np.array(decli)

# Q1 Plot the marginal PDF of each data set
# Days
plt.hist(day,bins=100, density = True)
plt.xlabel("Time (MJD)")
plt.ylabel("Marginal pdf of time (MJD)")
plt.show()

# logE
plt.hist(e, bins=100, density = True)
plt.xlabel("$log_{10} (E/GeV)$")
plt.ylabel("Marginal pdf of log(E)")
plt.show()

# Right Ascension
plt.hist(asc, bins=100, density = True)
plt.xlabel('Right Ascension')
plt.ylabel('Marginal pdf of right ascension')
plt.show()

# sin(declination)

# is magnifying the data at pole better resolution
print("##################################################################")
print('Using sin declination helps us to zoom in the data')
print('Which gives us a better resoultion at the polar region')
print('##################################################################')
# This means that the bin size are decreased hence increase our resolution
# Magnification is suppose to be sec(x) in this case

sind = np.sin(dec * np.pi / 180)
plt.hist(sind, bins=100, density = True)
plt.xlabel('sin(declination)')
plt.ylabel('Marginal pdf of sin(declination)')
plt.show()

# Q2 Plot the marginal CDF for logE
plt.hist(e, bins=100, cumulative=True, density=True, histtype = 'step', lw='2')
avg = np.mean(e)
q10 = np.quantile(e,0.1)
q50 = np.quantile(e,0.5)
q90 = np.quantile(e,0.9)
std = np.std(e)
plt.axvline(x=avg, color = 'g', label = 'Average')
plt.axvline(x=avg+std, color = 'm', label = '$\pm$ stddev', linestyle = 'dashed')
plt.axvline(x=avg-std, color = 'm', linestyle = 'dashed')
plt.axvline(x=q10, color = 'r', label = '10% Quantile', linestyle = 'dotted')
plt.axvline(x=q50, color = 'b', label = '50% Quantile', linestyle = 'dotted')
plt.axvline(x=q90, color = 'y', label = '90% Quantile', linestyle = 'dotted')
plt.xlim(0,7)
plt.xlabel('$log_{10} E/GeV$')
plt.ylabel('Marginal cdf of log(E)')
plt.title('cdf for $\log_{10}(E/GeV)$')
plt.legend()
plt.show()

# Q3 Plot the marginal PDF for time difference between concecutive events for all positive time event
# And time difference less than 1000s, use second as unit

pdiff = []

for i in range(len(day)-1):
    k = day[i+1] - day[i]
    if k > 0:
        pdiff.append((k*86400)) # converting MJD to second

timediff = np.array(pdiff)

t1000 = timediff[timediff<=1000]

print('################################################################################################')
print('Setting the scale to logarithmic makes it easier for you to intepretate the data')
print('We can see that majority of the event has a time difference less than 10k')
print('For time difference less than 1000s, we can see most of them has a time difference less than 10s')
print('Which means event times are not distributed evenly')
print('Second graph in general is zooming into the dataset')
print('################################################################################################')

plt.hist(timediff, bins=100, density = True, histtype = 'step', lw = 2)
# Setting the x-scale into log and default is log10
plt.xscale('log')
plt.xlabel('Time difference for concecutive event in logarithmic scale')
plt.ylabel('Marginal pdf for time difference')
plt.title('Marginal pdf plot for concecutive events')
plt.show()

plt.hist(t1000, bins=100, density = True, histtype = 'step'
)
#plt.xscale('log')
plt.xlabel('Event time difference less than 1000s in logarithmic scale')
plt.ylabel('Marginal pdf for time difference less than 1000s')
plt.title('Marginal pdf for time difference less than 1000s')
plt.show()

# Q4 Plot the joint pdf of sin(declination) vs logE

# obtained from the lecture notes code
print('######################################################################################')
print('y-axis represent the sin(declination) and zero is the celestial equator')
print('Top half of the graph is the northern celestial hemisphere')
print('We can see that the joint pdf shows how different the data are in different hemisphere')
print('######################################################################################')
_,_,_,image = plt.hist2d(e, sind, bins=100, density = True)
cbar = plt.colorbar(image, label = 'Joint pdf')
plt.title('Joint pdf of sin(declination) vs $log_{10} E/GeV$')
plt.xlabel('$log_{10} (E/GeV)$')
plt.ylabel('sin(declination)')
plt.show()

# Q5 Plot a scatter plot of dec. vs RA

# Source: https://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_scatter.html
fig = plt.figure()
ax = fig.add_subplot(111, projection='mollweide')
plt.grid(True)
plt.gcf().set_size_inches(10, 10)
plt.title('Mollweide projection of dec. vs RA')
# Shifting RA since data is recorded from 0 to 360 but we have -180 to 180
# Use radiant to obtain actual plot which I fiugred out after the code for debug
# Tho I am not so sure how to use this projection fully
c = ax.scatter(np.radians(asc[0:10000] - 180 ), np.radians(dec[0:10000]), color = 'r', marker = '.', alpha = 0.3)

# Code for debug
# coord = np.array([(0,30), (60,-45), (240,15), (150,-75)])
# dd = ax.scatter(np.radians(coord[:,0]-180),np.radians(coord[:,1]))
# print(coord[:,0])

# Q6 Plot Joint pdf of sin(declination) vs RA

# code source from lecture example
_,_,_,image = plt.hist2d(asc, sind, bins=100, density = True)
cbar = plt.colorbar(image, label = 'Joint pdf')
plt.title('Joint pdf of sin(declination) vs RA')
plt.xlabel('RA')
plt.ylabel('sin(declination)')
plt.show()

# Q7 Covariance Matrix of logE and sin(declination) of northern sky
nlogE = []
nsindec = []
for i in range(len(dec)):
    if dec[i] > -5:
        nlogE.append(e[i])
        nsindec.append(np.sin(dec[i] * np.pi / 180))
# use built in function to calculate the covariance matrix
nE = np.array(nlogE)
nsind = np.array(nsindec)
cov1 = np.cov(nE, nsind)
print("The covariance matrix for log(E/GeV) and sin(declination) of the northern sky is:")
print(cov1)

# Q8 Covariance Matrix of logE and sin(declination) of southern sky
slogE = []
ssindec = []
for i in range(len(dec)):
    if dec[i] < -5:
        slogE.append(e[i])
        ssindec.append(np.sin(dec[i] * np.pi / 180))

sE = np.array(slogE)
ssind = np.array(ssindec)
cov2 = np.cov(sE, ssind)
print('The covariance matrix for log(E/GeV) and sin(declination) of the southern sky is:')
print(cov2)

# Q9 Choose two declination randomly in southern sky
# Plot together the conditional pdf of logE for the two declination
# In lecture we said the definition is between -5 degree to -90 degree

# numpy randomly choose two number between -5 to -90
# Here we pick all integer
rd = np.arange(-90.,-4.)
randdec = np.random.choice(rd,2)
a = randdec[0]
b = randdec[1]
# vstack + transpose make this into 2D array
# dle stands for datalogE
dle1 = np.vstack((dec,e)).T
dle2 = np.copy(dle1)

# This is how you index 2D array and code source is from lecture example
# this process filter out the row that doesn't fit between the two data point
# for array index [:,1] means scan through all row but only 2nd column

dle1 = dle1[dle1[:,0]<=(a+0.1)]
dle1 = dle1[dle1[:,0]>=(a-0.1)]

dle2 = dle2[dle2[:,0]<=(b+0.1)]
dle2 = dle2[dle2[:,0]>=(b-0.1)]

# Let's Plot
plt.hist(dle1[:,1], bins=50, density=True, lw=1, label = 'Declination a = {:.1f}'.format(a))
plt.hist(dle2[:,1], bins=50, density=True, lw=1, label = 'Declination b = {:.1f}'.format(b))
plt.xlabel('$\log_{10}(E/GeV)$')
plt.ylabel('Conditional pdf for x = {:.1f} and {:.1f}'.format(a,b))
plt.title('Conditional pdf f(y|x) for x = {:.1f} and {:.1f}'.format(a,b))
plt.legend(loc = 0)
#plt.xlim(0,7)
plt.show()

# Q10 Why?
# The northern sky data are more corelated to each other than the southern sky
# This can be seen in the 2D histogram in Q4 as well as the covariance matrix calculated in Q7 and Q8

# For the differences, according to this paper: https://iopscience.iop.org/article/10.3847/1538-4357/ab8561
# The northern sky data are dominated by atmospheric neutrinos
# The southern sky data are dominated by atmospheric muons
# Which we ended up having much more data in the northern sky

# How long?
# 10 hours